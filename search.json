[{"title":"vps心得＆部署一些工具感想","url":"/2024/12/14/vps%E5%BF%83%E5%BE%97%EF%BC%86%E9%83%A8%E7%BD%B2%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E6%84%9F%E6%83%B3/","content":"\n最近因為朋友的surfshark到期了，加上自己想獲得一個連線到日本的節點，以及希望有一個public ip可以拿來建立一些web service，上網研究了一下購入了日本的VPS服務。\n在一篇講馬娘如何繞過cygames的檢查的巴哈文章裡面看到了 WebArena Indigo ，一個月只要400多日幣就可以開一台VPS （spec如下，少的可憐 ＱＱ）對於我目前的需求來說還是蠻夠用了。\n\n\n\nInstance選擇？因為WebArena蠻多中國的文章都有詳述，開instance的介面說實在也蠻單純的，這邊就直接跳過開機的步驟（我也沒截圖 嘻嘻）。\n機器本身就是一台qemu/kvm，可以選centos/ubuntu等常見的distrubtion，似乎也有windows server的選項，但想到license的溢價，對我個人來說是完全沒考慮過，就一台vps打天下吧！\n另外平台也有提供snapshot功能，但snapshot也要依照儲存時間計費，實在太不划算了，趕緊弄一弄自己的IaC做自動部署環境那些，感覺還比較實際。\n\n首先拿來幹嘛我個人的使用目的第一號，是想要一個日本的網路節點可以拿來看一些日本動畫之類的（動畫瘋不是什麼都有），但大家也知道日本的網路服務非常的鎖國外IP，甚至三大csp/oracle的都被ban光光，更別說那些每天看得到廣告的vpn品牌可以說是完全不用想拿來看任何日本網站。\n所以首先就使用這邊開的instance來嘗試連線，很幸運的沒有在我想使用的服務的block list中，順利用100多台幣獲得一台好夥伴。\n\n部署了什麼服務TW forum feed 化大作戰在去年開啟了gcp試用的期間，我使用golang簡單寫了一些cloud function拿來做ptt/噗浪的貼文feed化，repo在這邊go-feed-tool原本是使用cloud function形式，試用了Cursor來進行web server的改版，用起來還挺得心應手，大約在半小時～一小時的區間就成功部署成為web server app，還做了一些功能的調整更新。\n\nRSS feed telegram bot因為我個人和交友圈，最常使用的social app其實是telegram，telegram有著碾壓其他社群軟體的跨平台同步速度，更扯的是他的bot是完全不用收錢，為了讓自己更方便「被動」獲取一些論壇資訊（真的花太多時間滑PTT= =）我使用了公開repo RSS-To-Telegram-Bot，部署到自己的機器上，在做for個人的RSS通知機器人。\n順帶一提這個作者也有一個共同使用的bot公開，但為了自己rss註冊表資料的可控、隱私、還有爬文web app說實在也不想隨便暴露，所以自己建在自己機器上對我來說比較適合一些。\n\nNuget To Unitypackage 服務使用Unity的時候，如果想使用nuget的package(例如大家都愛的Newtonsoft.Json)其實是一件相當麻煩的苦差事，現在大部分使用 NuGetForUnity 專案來管控下載以及dependency等，但有時候只是想單獨使用某一包，也不想安裝這個專案（有時候覺得太過龐大），所以簡單做了一個web service + executable的程式，可以使用nuget下載package，自動選擇對unity專案較為適合的target，建立asmdef的關聯，最後打包成unitypackage可以一鍵置入專案。\n專案在這：nuget-2-dll-go\n值得一提的是，在部署這個服務的時候遇到蠻多問題，第一個是目前前面的服務docker image都是基於alpine就可以運行，但這個專案因為需要nuget，使用debian會是相對穩定的執行環境，所以程式在build的時候雖然一樣基於golang的alpine環境建立，但執行環境我選擇了debian:bullseye-slim，沒想到才是噩夢的開始…\n首先是因為其他docker-compose都在正常進行中，所以機器本來記憶體就所剩不多，在安裝debian的nuget的時候又會調用到蠻大量的記憶體，結果我這台只有1G記憶體的vps直接吃不消，被out of memory killer砍翻了，機器當掉好幾次。\n後來開著htop同時監督，才發現這個階段記憶體完全用到超過90%，後面是不可能完成的，還好這vps雖小還是給了20GB的SSD，趕緊的切了2GB當swap file，才真的成功部署到機器上（kernal版本不給我跑zram orz，不然真的不太想直接開到swap file）。\n其他部署問題因為這期間我也購入了自己的domain name，所以用了traefik來做簡易的LB/reverse proxy，把這些服務都分到不同的subdomain去。\n結果發現Cloudflare的dns，好像會自動上https，所以處理CA憑證那邊也花了快半小時左右，才成功把這些service公開出來讓自己的rss reader使用。\n\n接下來要做什麼目前還在想有什麼服務可以部署，但作為一個遊戲開發者，感覺自己應該要開始拓展多人遊戲的開發技能了。\n這個機器小到離譜，所以如果拿來做relay server感覺可能會翻車，目前構想應該是做簡單的match-making/lobby，然後打通STUN之後讓玩家們直接nat punchthrough來連線？ 不曉得unity netcode有沒有別人寫好的套件可用，Unity自己要賣Cloud Service的Relay Server，感覺肯定不會推薦用p2p遊玩 lul。\n\n總之最近買了vps/domain name等，又複習了一大堆linux admin的設定，還有現代雲的一些常用工具等等，接下來如果可以蹭到一些oracle的機器，感覺可以開始導入一些Terraform之類的IaC之類的來做自動化部署etc。\n後端技能樹越點越多的Game Programmer是不是搞錯了什麼？ 為了自清自己是Game Programmer指好放一下自己上電視的片段已證清白 ｈａｈａ\n\n\n\n","categories":["Software Development"],"tags":["Linux","Docker","Software Development","Backend"]},{"title":"打造self host的第二大腦","url":"/2026/01/18/%E6%89%93%E9%80%A0self%20host%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%85%A6/","content":"起因我以前一直就是pocket這個軟體的大粉絲，很喜歡在pocket存一些medium或是hackernews看到的有趣的知識文章、技術文章，甚至是一些人生相關的優文。\n\n沒想到去年五月的時候Mozilla宣布把pocket關閉，在那之後我就只剩下把這些資料存到telegram的saved message中（然後就再也懶得打開）\n\n仔細想想這樣真的是有點慘，今天早上心血來潮，覺得重拾這個知識管理系統，這次要用可以self-host的東西才不會再次被別人收掉。\n\n這次我跟著gemini聊天一邊follow up一邊把我的系統建立起來，發一篇文章留個紀錄。\n\n為什麼選用gemini聊天\n為什麼這次我選擇用web的聊天介面，而不是claude code / github copilot / open code或是antigravity這種開發介面？\n\n因為我目前已經有部署好的vps，架設好的n8n，和一個已經在運行的telegram bot作為我的calendar agent，我總覺得直接建立一個新的web服務不會是最順暢的流程。\n\n正好，幾年前就有耳聞obsidian非常厲害，這次想說來使用self-host在GitHub上面的obsidian流程來做做看。所以和gemini聊了聊系統設計。\n\nObsidian的vault建立這步驟好像也不需要用到ai，簡單找了一篇教學下載Git plugin + GitHub快速建立了自己knowledge based的repo後，就可以快速建立iPad / MacOS / Windows可以互相共通的筆記本流。\n\nn8n 與 tg bot的串聯這次的整個經驗學到最多的，其實反而是n8n的agent based設計理念的完整實踐。\n\n原本我可能會想說是不是拉一個完整的Flow來做這些事情，但是這個其實就不是agent的做法。\n\nGemini建議我，可以建立一些sub-workflow，製作成agent可以使用的工具來進行。\n\n最後建立了以下兩個工具\n\nTool - Save to Obsidian\n\n這個工具做的事情很簡單，就是可以給agent呼叫，來在指定位置建立新的檔案，類似我想要的pocket存檔\n\n\nTool - Jina Reader\n\nJina AI是一個LLM友善的輔助爬蟲工具，有免費流量在我個人使用上非常足夠，這個工具可以呼叫一個url來取得文章內容。\n\n\n加入這兩個工具再微調prompt後，我原本拿來紀錄calendar事件的bot，搖身一邊獲得了可以自動記錄obsidian文章的能力，也就是我要的pocket功能了！\n\n\n在Telegram中聊天感覺如下\n\n\n成功完成當初想要的pocket功能，而且在文章中，還可以有AI的摘要、翻譯等優點，可以說比當年的pocket更加強大。\n\n","categories":["Software Development"],"tags":["Linux","Docker","Software Development","Backend"]},{"title":"實作分享 - 攝影機捕捉多角色","url":"/2019/02/08/Game%20Implementations/Multiplayer%20Camera/","content":"You can also see my post in Bahamut.\n最近在開發2D遊戲攝影機的時候，參考到一篇2D攝影機設計經典文章\n就是2015年的這篇 Scroll Back - 2D 捲軸遊戲的攝影機理論與實務 \n其中有提到，在多人操作的時候，會希望攝影機能照到所有角色，這篇就將討論如何實做這件事。\n\n\n分析在開始製作之前，我們先試著簡化遇到的問題\n\n從上面這張圖來看，四個紅圈是我們的目標(角色)，我們希望的是將他們都顯示在畫面中。那也就是說，我們希望能夠用一個長方形(螢幕)來塞下他們全部。\n如下圖\n\n我當初看到這個問題的時候，馬上想到演算法學到的convex-hull問題，找出最小凸包之後，就可以沿著凸包求得最小的方形。\n但是在我們攝影機不會旋轉的情況，我們不需要那麼麻煩，因為軸是固定的，我們只要找到這些點之中最大和最小的x,y值即可如下圖\n![Smash] (https://i.imgur.com/wEs8HUp.png)\n判斷的程式碼如下\n\n接著我們就可以利用判斷出來的這四個點做延伸，找出目標的長方形\n\n此時將攝影機放在這個長方形的中心點，再將攝影機縮放到比長方形大小還要大，就可以拍到所有角色囉！\n實作接下來實作長方形大小的計算，以及攝影機的縮放部分\n這邊我的攝影機縮放以orthographic的攝影機為例(因為直接size乘上去就好)，使用投影的情況就再額外計算Z軸距離吧！\n以下是我實作的程式碼：\n使用前面說的方法獲得整個長方形的四個點之後，可以簡單地算出他們的中心點(第15行)接著算出畫面長寬相對於長方形的長寬比例，將較大的一方回傳給攝影機設定就可以了！(17~20行以及22行所做)\n執行結果大致如下影片\n\n\n\n整個專案的repo在這，如果有興趣也歡迎參考使用喔XDhttps://github.com/HaoxDev/UnityPractices\n","categories":["Game Implementations"],"tags":["Basic","Fun","Camera"]},{"title":"UniAvatar - 簡易Unity對話系統 (操作篇)","url":"/2020/04/18/Game%20Implementations/UniAvatar_Intro/","content":"Demo畫面鎮樓\n簡介UniAvatar是一個使用Unity製作的簡易對話系統，與文字冒險遊戲的範例。\n專案所撰寫的程式碼均開放原始碼，且遵守MIT Lincense，但專案中的ADV實作部分有參考使用其他專案，使用時請參考各自的開放協議。\n感謝ArmeCyan提供立繪與UI的支援，如果喜歡他的畫風請去粉專支持。\nRepository連結：https://github.com/Harrison-Dev/UniAvatar\n範例連結: 點我\n如果有任何希望追加的功能，歡迎在repo中發issue或是PR協助專案變得更完整！\n\n操作說明目前Repo上的版本是以Text mesh pro為主進行設定的，所以這次的操作步驟也會是以TMPro為主。\n如果想使用一般UGUI Text，可以在Player Setting中，將TMP_SUPPORT Define拿掉即可。\n\n場景架構打開專案後，首先要打開範例場景TextMeshProExample。\n打開範例場景TextMeshProExample之後，可以看到場景是由一個Canvas作為主要組成，在Canvas最底下的是Controller們，這部分會在之後的實作細節文章中再仔細提到。\n\n稍微簡單介紹UGUI中的架構，主要分為背景(背景圖片與物件)、中景(人物與相對應互動)、前景(對話框等UI物件)，最前方是操作時會點選的Panel物件與選項框物件。\n可以透過調整下方的人物圖片、UI圖片等，來製作屬於自己的ADV遊戲。\n注意：如果調整名字時，記得在Animation Manager中調整Animation Target對應的Key，以免動畫沒辦法正確對應\n\n關於動畫等系統詳細的介紹，會在之後的文章中慢慢補上。\n介紹完外觀上的架構後，讓我先來介紹一下對話內容的設定吧。\n對話設定這個專案參考了許多的文字冒險遊戲設定方法，最後決定以試算表作為文本設定的方式進行編輯。\n可以參考 範例所使用的文本 中所使用的格式。\n也可以自由將這份文件自己複製一份，方便自己編輯劇情文本。\n第一頁列出目前所實作的Action的種類，以及其對應的參數，這個設定檔算是紀錄目前的功能以及與企劃同步資訊用的，不會實際讀進遊戲中。\n\n可以看到目前實作了對話、動畫、選項、分支四大類別。\n在第二頁中，可以看到透過前述的這些分類設定了範例的對話內容：\n\n其中的參數意義，請參考第一頁所列出的內容。\n大家可能注意到了，其中第一頁不管是名字，或是對話內容都有個Key在結尾出現。\n這是因為這個系統也製作了簡單的翻譯用文字表格：\n\n目前只是使用Google Spreadsheet的內建Google Translate，請大家不要太在意翻譯品質。\n第一行的Key為了在劇情表中可以一眼看出對話內容，目前暫時使用整句中文語句作為主要key，可以依照實際翻譯所需進行調整。\n\n最後一個列表是遊戲中的變數們，實際使用的時候只會用到第一列的值，後面只是方便記錄這個變數實際上的作用。\n將對話設定匯入引擎的步驟這一個段落會敘述如何將上述的劇情與文本等文件，匯入到Unity引擎中使用。\n首先將前面的試算表點選 檔案 [→] 下載 [→] 逗號分隔值檔案\n將ActionSetting, Words, Flag 三個檔案都下載下來\n\n將下載出來的檔案覆蓋下面資料夾中的三個檔案\n\n檔案覆蓋後，回到上一層的目錄\n\n將三個目錄最上面的按鈕都點選重新讀檔，就可以將新的文本覆蓋了！\n\n最後，因為這個範例是使用Text Mesh Pro進行製作，所以要更新Text Atlas\n首先點選這個資料夾中的SDF檔案\n在Inspector中點選Update Atlas\n跳出Text Mesh Pro視窗後，接著將選單選擇到From File\n最後按下Generate，最後按下Save就可以將Text Atlas更新了\n接下來回到場景執行，就是更新後的文本了！\n\n遊戲範例範例所使用的文本\n※這個範例與試算表的文本是直接同步的，但是目前公開的Repo並沒有包含下載功能。\n\n \n\n\n\n\n相關文章 (陸續更新)\n操作介紹\n故事主控器介紹\n動畫主控器介紹\n多語言實作介紹\n讀取設定檔介紹\n\n","categories":["Game Implementations"],"tags":["Basic","Fun","Camera"]},{"title":"Introduction to Game Rotation","url":"/2019/11/01/Game%20Mathematics/Introduction%20to%20Game%20Rotation/","content":"You can also see this article in my medium post.\n\n我在接觸3D遊戲引擎時，一開始對旋轉這件事感到很困擾，\n在Unity的編輯器中，旋轉的表現形式看起來像三個顏色的球狀旋轉。在Transform裡面又是有著3個數字的向量形式，到了程式碼裡面，又變成Quaternion這種資料形式，讓人一時之間很難搞懂。這篇文章會記錄一些我對於旋轉的表示方法、各種表示方法的優缺點的理解，以及使用上的一些轉換方式。最後再用一個範例，在Unity中藉由滑鼠拖拉旋轉攝影機來表示如何用程式簡單控制旋轉。\n\n三維空間中的旋轉表示最為常見的用法有三種：矩陣、歐拉角以及四元數\n矩陣(Rotation Matrix)矩陣方式就是我們所熟知的旋轉矩陣，利用一個3×3矩陣，表示從一個基準的座標，旋轉到目標的座標所使用的旋轉矩陣，換言之，矩陣形式就是將旋轉表示(orientation)轉換成旋轉表示的數學形式。\n\n利用矩陣形式的最大優點，就是對於三維空間座標的向量旋轉是可以立刻使用的，並且可以簡單取得相對的角位移(angular displacement)。而缺點部分就是相對於其他旋轉的表示方法，需要花到9個數字的儲存空間，並且經常會造成浪費，因為時常我們可能只需要相對某個轉軸的旋轉。\n歐拉角(Euler Angle)歐拉角是將旋轉的定義，從用數字一次定義出來，改變為依照順序對不同軸向進行旋轉，依照heading-pitch-bank定義三個旋轉為heading angle, pitch angle以及bank angle。Heading rotation是沿著y軸進行旋轉，Pitch rotation沿著x軸進行旋轉，Bank rotation則是沿著z軸進行旋轉，字面上定義依照這個順序進行歐拉角的旋轉。值得注意的是，歐拉角的旋轉不只有heading-pitch-bank方式，還有roll-pitch-yaw等不同的旋轉方式以及順序，像在Unity中，就是以這種方式旋轉，Unity的歐拉角的旋轉順序是沿著Z軸旋轉(roll)，再來沿著X軸旋轉(pitch)，最後沿著Y軸旋轉(yaw)。\n\n歐拉角的最大的優點，就是歐拉角對於閱讀起來十分直觀，是人類可以直接判別的旋轉方法。此外，歐拉角也是對於旋轉最為簡潔的表達方法，只需要3個數字就可以表達出一個旋轉，是最為節省記憶體的方法。但是，看似如此方便的歐拉角，卻存在著兩個非常嚴重的缺點：\n1. 表示同樣旋轉的歐拉角並不唯一也被稱作別名(aliasing)問題，例如在角度上加上360度，就是一種最單純的別名問題，因為對角度加上360度並不會改變他的角度。但是這類別名問題只要限制角度範圍就可以解決，並不會造成太大的困擾。真正麻煩的是第二種，因為三個角度並不互相獨立的造成的問題，例如pitch 135度與 heading 180度加上pitch 45度(向下旋轉)是等價的旋轉表示。對於這種別名問題，常見的做法是限制他的旋轉角度，例如限制heading/bank在 －180 ~ +180之間，將pitch限制在－90 ~ +90之間。然而，就算限制了上面所說的角度之後，仍然會存在一個問題，被稱為萬向鎖(Gimbal Lock)，最為著名的舉例就是先head 45度再pitch 90度，與先pitch 90度再banking 45度是相同的，其最根本的原因就是pitch ±90度之後，使得另外兩個轉軸重疊，此時兩個轉軸旋轉任意角度都會造成別名問題。\n\n為了消除萬向鎖造成的別名問題，可以規定萬向鎖發生時，只交由某一個軸去完成旋轉，假如約定以heading完成全部旋轉，bank在萬向鎖發生時就會永遠為0。\n2. 對於兩個旋轉表示的內插(Lerp)的問題角度的內差第一個會面對的問題，是歐拉角旋轉的週期性所產生的，例如要從heading -150旋轉到heading 150，就存在著60度的短弧與300度的長弧之分，解決這類問題就是將插值的差角限制到正負180度內，確保旋轉在最短弧上。而在旋轉角度內插上，歐拉角會遇到最大的問題，還是前面提的萬向鎖問題。在單純地將歐拉角進行差值運算時，如果遇到萬向鎖問題，大多情況會導致錯誤的路徑，抖動等等問題，在萬向鎖情況旋轉歐拉角，需要將兩個角度分開旋轉，但是以攝影機的轉向操作為例，在球面上光滑旋轉才是最舒適的表現方式。而歐拉角在旋轉上所遇到的萬向鎖問題，很不幸的目前並沒有任何好的數學解法，這也是歐拉角沒辦法作為最主要旋轉表示的主要原因。\nMore information : https://www.youtube.com/watch?v=zc8b2Jo7mno\n四元數(Quaternion)四元數的定義四元數原先是一個四維的複數空間的表示方法，在幾何上的應用，可以作為一種旋轉的表示方式。數值上，存在一個定標器(scaler)w以及一組三維向量v或是直接拆分成x,y,z(Unity中，可以直接取得w,x,y,z四個數值)。四元數可以代表一個複數空間中的座標，其中[w, (x, y ,z)]被定義成w+xi+yj+zk。其中的i,j,k有如同二維複數空間的性質：\n\n    i^2 = j^2 = k^2 = -1\n    ij = k, ji = -k, jk = i, kj = -i, ki = j, ik = -j如同二維空間的複數座標可以旋轉二維向量，四元數也可以拿來旋轉三維向量。而四元數中的四個數字究竟是什麼意思呢？從歐拉角我們可以得知，一個三維的旋轉表示可以被表述成一個旋轉軸加上一個旋轉角度，四元數也是用這個概念表示的，假設有一個旋轉軸n加上旋轉角度θ，整個四元數可以被表示成：\n\n    [w,v] = [cos(θ/2), sin(θ/2)\\hat{n}]\n    [w,x,y,z]  =  [ cos(θ/2), sin(θ/2) n_x,  sin(θ/2) n_y , sin(θ/2) n_z]四元數的性質們\n完全沒有旋轉的四元數被稱為identity，數值為[1,0]和[-1,0]，其中的0表示零向量。\n\n在旋轉表示的用途中，我們只使用單位四元數(Unit Quaternion)，即模數為1的四元數。\n\n\n\n    ||q || = [w,v] = \\sqrt{w^2 + ||v||^2} = 1\n四元數的運算\n四元數的乘法沒有交換律，q1q2 ≠ q2q1。\n四元數的乘法存在結合律， (q1q2)q3 = q1(q2q3)\n四元數的乘積的模數等於模數的乘積(||q1|| ||q2|| = ||q1q2||)\n四元數的乘法可以表示兩個旋轉的結合，進行q1再進行q2，可以合併成q3 = q2q1(旋轉順序由右向左)\n四元數的旋轉差為反四元數，q1到q2的旋轉量為：d = (q1^-1) q2\n\n\n\n還有許多未提到的四元數運算如點積、Quaternion Interpolation(Slerp)等，在基礎篇裡面就先省略，如果有下一篇再補上相關資訊&lt;( )&gt;。四元數的優點是可以平滑插值計算，並且可以快速計算角位移以及轉換成旋轉矩陣，而且只用到四個數字進行存取，記憶體消耗較低。四元數的缺點則是跟矩陣類似，相較歐拉角更大的記憶體用量，並且比旋轉矩陣更難直接讓人類判讀。\n轉換成四元數在Unity引擎裡面，Transform所顯示的旋轉角度是歐拉角，腳本上取得的Rotation則是四元數，理解兩者之間的轉換方式可以讓使用上更為方便。為了更符合Unity內的使用，在這個段落中，歐拉角的表示方式將使用roll-pitch-yaw來表示。\n將歐拉角轉換成四元數在前面我們了解到，四元數可以藉由相乘來完成連續旋轉，所以我們將把rolling, pitching, yawing分為三個四元數進行旋轉，最後再將它們串成同一個四元數。根據四元數的定義，可以轉換如下：\n\nReferenceWikipedia:https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angleshttps://en.wikipedia.org/wiki/Quaternion\n3D Math Primer For Graphics and Game Development:Amazon : https://www.amazon.com/Math-Primer-Graphics-Game-Development-ebook/dp/B008KZU548\nUnity Rotation Guide:https://docs.unity3d.com/Manual/QuaternionAndEulerRotationsInUnity.html\n","categories":["Game Mathematics"],"tags":["Basic","Game Math"]},{"title":"2D Collision Study","url":"/2020/02/25/Game%20Physics/2D%20Collision%20Detection/","content":"\nCircle / Rectangle CollisionCircle CollisionCircle collision is much easier, only need to determine distance between centers &gt; sum of radius.\n\ndistance = \\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}\n\nAxis-Aligned Bounding BoxDetermine 2 rectangles without rotation is collided or not.\nCheck the bounds of each rectangle with width &amp; heightThat is check :\n\nrect1.x < rect2.x + rect2.width \\\\\nrect1.x + rect1.width > rect2.x \\\\\nrect1.y < rect2.y + rect2.height \\\\\nrect1.height + rect1.y > rect2.yAll of above conditions are satisfied.\n\nAABB in UnityBounds\nRepresents an axis aligned bounding box.An axis-aligned bounding box, or AABB for short, is a box aligned with coordinate axes and fully enclosing some object. Because the box is never rotated with respect to the axes, it can be defined by just its center and extents, or alternatively by min and max points.\nSeparate Axis Theorem (SAT)Separating Axis Theorem (SAT for short) states if you are able to draw a line to separate two polygons, then they do not collide.\nSAT :\nIf we can find out separate axis,two polygons doesn’t collide each other.\nAlgorithm:\nFind out separate axis of 2 polygons.\nHow to find SAT?\nJust like Axis-Aligned Bounding Box,project each vertice onto each edge.\n(AABB method use x-y axes to detect)\nFinding SAT\nIt’s not reasonable to search all axes for finding a SAT.\nSelect the candidate axes for finding SAT!\nThe axes must test are the normals of each edges from shapes.\n\nFinding SAT Algorithm\nFind all normals from each shape\nFind all project point for all vertices on each normal\nFind if there is at least 1 separate axis or not.(projection1.max &gt; projection2.min &amp;&amp; project2.max &gt; projection.min)\n\nFind Minimum Translation VectorTracking the the minimum overlap and axis when we finding SAT.Use this vector to separate shapes.\nStill some problem…TunnelingDiscrete simulation can lead to missed collisions and tunneling. In this case the ball falls out of the world.\nSome of CCD resources:  \nUnity : Continous Collison\nErin Catto : Continous Collision\n","categories":["Game Physics"],"tags":["Basic","Game Physics"]},{"title":"Game Physics - Constraint","url":"/2020/04/25/Game%20Physics/Physics%20Constraint/","content":"\nPreface先前2月參加了Unity應用領域舉辦的CJ貓大大的講座，\n非常感謝CJ大大的分享跟連大辛苦尋找場地，\n想說也將自己吸收學習到的內容整理成文章，與各位的開發者大大們一起參考學習。\n文章的內容是參考CJ大大的專案內容與Box2D作者ErinCatto大大的GDC演講所整理，這兩份資料都在文章最下方的reference中\n\nConstraint每一個物理系統時常會有一些約束，物體的運動也必須遵守這些約束。例如，簡單擺系統的約束是擺繩的長度是常數，擺錘與支撐點的距離必須是這長度。 (來自維基百科)\n基本概念就是：\n\n約束是拿來在像是Joint、Motor、Restitution, Friction與Contact等物理模擬中使用\n像是疊箱子或是ragdoll的四肢的接點等也會運用到約束\n解約束是透過計算衝量或作用力並且將這些結果貼回受約束物體的過程\n\n地面約束地面約束是被地板擋住的簡單約束，我們想將物體限制在地面上，所以位置方程式可以表示成：\n\n可想而知，如果C等於0，他對時間的導數也會為0。所以速度約束可以表示成：\n\n將速度的y方向做限制，得到：\n\n畢竟真實的物理世界並不是如此僵硬的直接彈回去，為了擬真會再加上一個偏誤值做緩慢修正：\n\n我們就可以得到地面約束的速度數學式：\n\n程式碼實作可以參考CJ大大的repo\n通則化這部分相當的數學，我參考消化花了不少時間，如果有什麼地方寫得不清楚，歡迎留言詢問。\nJacobian矩陣根據Chain Rule，推導出的速度限制會有如下形式：\n\nJ是一個row vector，被稱作Jacobian Matrix，會取決於被限制物體的位置。\n根據速度約束，我們最後要得出的結果是：\n\n轉換為Jacobian矩陣的形式，也就是：\n\n由此可知，Jacobian這個向量是與速度垂直的。(row vector J 內積 column vector v結果為0)\n以前面地面約束舉例，可以寫成以下形式：\n所以最後通則化的結果：\n\n其中J是Jacobian矩陣，V是速度矩陣，b是偏誤(bias)\nLagrange Multiplier先從約束的力開始推導：\n\n如上圖：可以直觀的發現約束力的作用方向是與約束平面的法向量平行的。\n而Lagrange Multiplier的定義是\n所以可以用前面的通式與牛頓第二運動定律，解出Lagrange Multiplier\n\n以前面的地面約束為例，可以用這個方式推導，解出速度變化的通式：\n\n而最後的速度變化就可以寫成程式進行約束模擬。\nReferenceAllen Chou - Physic Constraintshttps://github.com/TheAllenChou/unity-physics-constraints\nErin Catto - Box2Dhttps://box2d.org/\n","categories":["Game Physics"],"tags":["Basic","Game Physics"]},{"title":"Fiber based job system","url":"/2022/07/27/Game%20Programming/Fiber%20Job%20System/","content":"Preface工作上使用unity開發遊戲時，在效能有瓶頸的區塊時常會使用到Job System來提升效能，去年因為興趣使然稍微研究了Job System的底層實作，在公司內部報告使用過，藉著最近有點時間將這些資訊整理起來發成部落格文章。\n寫完之後回頭來看，必須先提醒一下，這篇會使用到相當多作業系統的背景知識，建議讀者需要先具備作業系統的基礎再做閱讀。\n\n\nWhat is Job SystemJob system是一種管理多執行緒(multi-thread)程式的封裝，藉由將執行的程式碼打包成一個個任務，來抽象化執行續本身的使用。\nJob System藉由管理一組 worker thread進行跨CPU core的資源使用，通常使用與CPU core數量相同的worker thread數量，來避免頻繁的上下文交換(context switching)所帶來的效能損失。(即使作業系統或其他程序可能會使用到一些核心的資源)\nJob System 藉由將 Job 推入一個 Queue (或是priority queue)，將他們依序放入worker thread執行，同時Job System會管理他們之間的依賴關係來確保 Job 依照邏輯順序進行。(像是NPC走到定點後，才開始進行巡邏)\nNaive Job System Structure\nWorker threads : 使用std::thread::hardware_concurrency() 獲得CPU核心數，生成對應數量worker thread\nJob queue : 由各個worker thread在空閒時自己抓取，所以需要是thread safe的資料結構\nCounter : 紀錄目前還在進行的job數量，可以使用 std::atomic\n\nFiberAbout Fiber-based Job SystemNaughty Dog在GDC 2015的演講是提出這個實作並且推進遊戲使用的非常重要的一篇文章，非常推薦大家閱讀。\nWhat is Fiber?根據 Microsoft Win32 的 Manaul 所述:\nA fiber is a unit of execution that must be manually scheduled by the application. \n\nFibers run in the context of the threads that schedule them.\nFiber具有以下特性：\n\n一個小型的 thread，由使用者提供stack space，並且具有更小的 context，可以將register暫存在stack上\n由 worker thread 執行\nCooperative (合作性) 的多執行緒執行，由fiber之間yield做切換，而不主動搶佔\n極小成本，不會有thread的context switching在fiber切換時發生 (只有register的save/load必然發生)，因為context都還在stack上\n\n同上所述，Fiber 之間的切換是使用yield進行，也就是所謂的cooperative scheduling，Fiber將這個cpu scheudling和context switching(kernel-space)的操作拉到使用者(user-space)進行，並且讓這些操作成為寫程式的基本步驟。這使得工程師可以在多執行緒的程式設計中取得更多的操縱權。\n在各式各樣的語言中都有著類似的東西，更多時候被稱為User-space thread或是green thread(Ruby, Java)。\n有些語言也有著coroutine的概念，fiber和coroutine也有相當程度的相似，只不過coroutine通常是語言層級的概念，而fiber通常做為系統層(system-level)的概念存在。\nFiber 的實作Fiber的實作是在組合語言層級進行，將所需的register存放到對應的stack空間，再藉由jmp跳到其他的上下文執行。如果沒有瘋到想自己實作，大可使用OS Support的Library來使用例如：Win32、Unix、boost/context\nFTL (fiber-based tasking library)為了進行實作練習，我找到一個滿完整的fiber job system開源專案進行參考\nRichieSams/FiberTaskingLib\nFTL使用上面提到的boost作為fiber的實作\nFTL 的 Fiber 實作Yield to other task\n分成兩個區塊進行，如圖：\n第一部分是使用boost/context的api，將context打包成fiber bundle，儲存到stack上，並且將目前的task丟進等待 queue 中\n第二部分則是從queue中找尋目前等候執行的task，將他填入目前的TLS (thread local storage)\n最後使用fiber api進行user-space的context switch就完成切換\n如何使用FTL\nCaller呼叫Job執行的部分，需要執行底下步驟\n\n\n初始化 job scheduler (in stack)\n創造task陣列 (也是stack)\n初始化job的參數\n將job kick到scheduler中\n等待atomic counter歸零 (job執行完成)\n\n程式碼如圖：\n\nCallee作為Job的function必須符合底下格式：\n\n\n如圖所示，送入目標的task scehduler以及參數來執行job化的程式碼\n簡單的一個例子如下：\n\n這是簡單對數字進行加法的程式，\n第一塊是主要邏輯進行的部分，也就是我們要平行化的部分\n第二塊是假如後面程式碼需要依賴其他task的結果，可以將目前context暫存，把執行資源yield給其他task執行，等待依賴的task執行完畢\n第三塊則是可以從這個job中開始其他的job的執行。\n實作我使用了FTL進行經典的flocking演算法boid的實作，2000隻的鳥群，在單核心的執行如下：\n\n使用job system優化後如下：\n\n還有進行一些kick now, gather later，以及double buffering之類的技巧優化以及將render thread和game logic thread拆開，因為不是這篇主題的重點，就不細講，有興趣的可以參考實作的Repo：\nHarrison-Dev/Boid-Jobify\n別忘了幫我留下一顆星星！\nReferenceJob conceptFiber ConceptMS FiberNaughty Dog’s SlideFiber Tasking libFiber vs Coroutine\n","categories":["Game Programming"],"tags":["Computer Orgnization","Operating System","C++"]},{"title":"關於C#記憶體管理那些事。","url":"/2019/07/27/Game%20Programming/Memory%20Management%20in%20Game/","content":"You can also see my post in Bahamut.\n使用Unity製作遊戲也好一陣子，\n途中踩過不少坑都是對於Unity預設值與C#程式語言的設計上的不熟悉，\n關於Unity預設值的部分，達哥在今年的TGDF上的簡報讓我獲益良多，大家都該去看看。\n這次想探討的是關於C#程式語言的設計方面，\n特別是相對於C/C++這些低階語言來說，C#/Java的記憶體分配像是一個巨大的黑盒子，\n運作起來還蠻順利的，但是時不時就會像樂高一樣踩到腳(而且很痛)，\n這篇就來記錄一下自己學到的東西，順便討論裝箱(Boxing)跟C#的記憶體運作吧！\n\n一、C#的記憶體分配由於看到文章的朋友，可能不一定對程式語言的一些處理非常孰悉，\n所以在這邊先簡單整理關於C#記憶體分配的一些規則。\n對C#來說，一個Class分成三種類型：\n\nValue Type 2. Reference Type 3. Pointer Type\n\n其中第三項要開啟unsafe才能夠使用，而Unity的預設值是關閉的，所以可以先不理它。\n前兩項Value Type跟Reference Type，在MSDN的官方說明上是這樣的：\nValue types are either stack-allocated or allocated inline in a structure.Reference types are heap-allocated\n可以了解到，\n對於Value Type來說，一般是存放在STACK段，做為區域變數使用。\n對於Reference Type來說，一般是存放在HEAP段，由C#的Garbage Collection控管。\n(當然這樣簡單的分類未必完全正確，因為他們其實存在一些實作細節的不同)\n簡單來說：\nValue Type就是一般常用的int, float, char, struct, enum這種簡單的資料型態，\n他們在一般情況通常是區域變數，也就是用完就丟的，對記憶體的消耗也不會太大。\nReference Type就是利用class包裝起來的資料了，他們會被整包放到動態記憶體裡面，\n如果不特別處理，就會持續占用記憶體，當相關的程式使用完這些變數，\nC#就會利用Garbage Collection的方法，回收這些用不到的記憶體，\n在Collect的當下會消耗較多CPU資源，甚至在手機上有可能會導致掉幀的情況，\n所以我們一般會希望迴避這種動態記憶體的分配能夠有所節制，\n也是前幾篇文章所提到的物件池存在的一部份原因。\n二、萬惡的Boxing跟Unboxing介紹完兩種C#的記憶體分配方式之後，再回頭討論標題的Boxing究竟是什麼意思吧。\n在寫遊戲程式的時候，常常會遇到一種狀況：\n「需要把現在的數值記錄下來，做為某種用途」\n這種情況，我們常常會宣告一個class，像是下面這種存檔用的資訊：\n\n在使用上，我們通常會寫成：\n\n這種形式，此時原本存在區域變數的level跟health，就需要複製一份到動態變數區，\n並且包裝成SaveFile的形式一直存在於動態變數區，直到它被使用完畢，被GC給回收去。\n這樣從區域變數(Value Type)被打包到動態變數區段(HEAP段)，就被稱為Boxing(裝箱)。\n反過來從動態變數區段擷取成區域變數(Value Type)就被稱為Unboxing(拆箱)。\n三、總結其實Boxing跟Unboxing在寫程式的時候幾乎是難以完全避免的，\n我們只要記得盡量少使用裝拆箱，以及在使用ArrayList, HashTable這種\n一放進去就會被轉型成object type的自動裝箱結構時，要務必小心使用。\n另外就是盡量在不忙碌的時候(打開UI選單、暫停遊戲、或讀取關卡時)，\n手動呼叫System.GC.Collect()進行手動GC，勢必可以稍微減少GC回收對效能造成的影響囉！\n參考資料：https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/types/boxing-and-unboxinghttps://docs.microsoft.com/zh-tw/dotnet/standard/garbage-collection/fundamentalshttps://docs.microsoft.com/zh-tw/dotnet/api/system.valuetype?view=netframework-4.8http://dev.yesky.com/msdn/359/3486359.shtml\n","categories":["Game Programming"],"tags":["Computer Orgnization","Memory Management","C# Programming Language"]},{"title":"Object pooling - 基本物件池與應用","url":"/2018/08/17/Game%20Programming/Object%20pooling/","content":"You can also see my post in Bahamut.\n什麼是Object pooling在我們製作一些遊戲的時候，常常需要使用到一些重複且相同的物件，\n如果我們照著一般物件產生以及消除的方法：Instantiate 以及 Destroy，\n會使許多GameObject(object)用完慘遭系統GC，如果像是子彈或者音樂遊戲的object被大量GC，\n很可能造成遊戲卡頓，對於音樂遊戲或者是捲軸射擊遊戲都是相當致命的傷害，\n為了避免這種問題，我們使用Object pool來儲存可以使用的object們，來免於上述的問題。\n那麼Object pool該如何在C#中實作呢？\n\n以下是一個Object pool 的簡單範例：\n\n可以看到，我使用Queue作為最基本的element存放結構，\n在這邊稍微補充Queue的作用給沒有聽過的人：\nQueue 是一個first in first out(先進先出)的資料結構，可以用來存放需要順序性的資料，例如網路\n傳送的封包等，Queue有幾個基本的操作：Enqueue可以將物件存放到Queue的尾端，Dequeue\n可以從Queue的開頭來拿取物件，對於我們這個object pool的實作並不是唯一的選擇，只是筆者\n習慣上所做的選擇而已。\n另外，在這個class中，可以看到建構子需要傳入創建object的創建方式，對於一般c#的物件來\n說，通常是以new運算子開頭的建構函數，而對於unity的GameObject來說，便是Instantiate方法\n了。\n使用上，只需要呼叫GetObject就可以接收到object pool內儲存的物件，如果物件池中已經沒有物\n件了，我們就會使用一開始指定的方法出創建新的物件來回傳。\n另外，當我們使用完這個物件之後，我們可以呼叫Recycle方法，將這個物件回收起來，這樣如果\n下次需要呼叫object pool裡頭的物件，我們就可以重複利用這個物件了！\n如何將物件池應用於Unity中我們目前實作的物件池，其實只能將物件這個reference記錄起來，避免它被系統給GC，但如果\n要真的在Unity裡面重複使用，還必須將物件本身藏起來才行，例如下面這個子彈發射的例子：\n\n在回收子彈時，同時將它設為Inactive。\n\n如果我們從pool中拿取子彈拿來使用，就必須將它Active，否則他是無法運作的。\n當然，在Unity的Object pool實作上面，除了將他Inactive拿掉以外，也可以將該GameObject移出\n遊戲畫面外，如果有較為耗效能的component再利用腳本關閉，這樣會比active該GameObject\n能獲得更好的效能，大家有興趣的話，也可以自己實作看看喔！\n這是上面的子彈範例專案檔，大家也可以下載下來試試看：Google雲端\n＊本文章提及所有code以及專案中所有code都可以任意修改使用，不需進行告知！\n","categories":["Game Programming"],"tags":["Basic","Data Structure"]},{"title":"京都BitSummit遊記","url":"/2023/09/10/Travel/%E4%BA%AC%E9%83%BDBitSummit%E9%81%8A%E8%A8%98/","content":"雖然說是遊記，但是其實這趟前往BitSummit是代表遊戲去出差的，這邊再放一次遊戲的連結，有興趣的麻煩加一下願望清單。\n\n\n\n\n第一天行程：前往京都時隔已久的來到機場掛行李處\n\n\n\n發現前往日本的人潮遠遠不及前往韓國的航班，我們搭乘的這班飛機甚至還沒客滿\n\n經過沒幾小時的飛行後，終於抵達關西國際機場，上次來這邊是小時候家庭出遊時跟團，可以說對這邊真的是非常陌生 🥹\n\n\n這次出差住在日本星野集團的OMO 5京都三条，房間雖然不大但是睡起來還是滿舒適的\n\n\n經過一天的舟車勞頓，在飯店的對面吃了一家居酒屋，有超棒的生魚片拼盤～\n\n\n\n吃完後回飯店養精蓄銳，準備第二天要開始擺攤之路了～\n\n第二天：擺攤第一天 (business day)\n這次承蒙資策會的邀請，在digi+的攤位展示我們的新作 star named eos\n\n\n攤位的正對面就是馬娘跟love live，被大型攤位攤夾擊壓力山大 \n\n\n趁活動還沒開始，側拍了一下我們的前作Behind the Frame在任天堂的booth展出中～\n\n\n\n\nBitSummit整場有非常 非常 非常多的知名獨立遊戲擺攤，也有一堆我超愛的遊戲的開發者在這，可惜第一天忙著擺攤與介紹給媒體們，沒有機會可以去和他們打招呼，像這個 alice esacped就是我特別愛的遊戲之一：\n\n\n\n\n在第一天的最後，有幸遇到SIE的兩位開發者支援大大，Greg Rice跟吉田修平試玩我們家遊戲🥰\n\n\n\n第一天擺攤結束後，進入開發者party環節，大家一起在會場裡面吃吃喝喝，結束了第一天的活動！\n\n\n\n\n以上就是我的流水帳BitSummit遊記前半，最後來講點心得好了。\n\n過去我在台北電玩展擺過幾次攤，也以玩家身份去參加過一次東京電玩展，我得說BitSummit和這些商業為主的電玩展真的非常不同。\n對於一個單機遊戲愛好者來說，這裡可以說是天堂，非常多超級有趣的獨立遊戲，也有一些大廠放了單機遊戲來給玩家體驗，最大的差異就是其他的電玩展多少還是存在一些舞台活動、或是遊戲本身以外贈品發送等誘因來讓玩家前往，但這個展幾乎所有攤位都是以遊戲為主，大家用遊戲溝通，用內容來交流，這件事真的作為一個玩家或是開發者都非常感動。\n台灣最接近的活動應該是G8電玩展了，希望G8展也可以越辦越好！\n\n後面幾天玩家日雖然也很忙碌，但我也忙裡偷閒玩了好幾款喜歡的遊戲\n","categories":["travel"],"tags":["game development"]},{"title":"UniTask：利用async/await優雅的撰寫callback","url":"/2021/09/05/Unity/UniTask/","content":"\nPreface前些日子因為一點小意外，需要在一兩天時間從零開始弄一個web service上雲，因為部分邏輯已經先用C#寫好了，平常也天天在用C#，沒想太多就用上了 ASP.NET core，沒想到意外的很香。\n除了.NET Core很香之外，這兩天的時間寫了寫MVC的Web service，意外地發現和寫遊戲前端截然不同的寫法，在寫web service的時候，C#的async功能可以說是用個不停。\n從以前就久聞UniRx差分出來的UniTask的大名，卻遲遲沒有機會與他相見，想說趁這個機會來碰一碰吧，碰巧，最近下班玩的一個插件，剛好使用Coroutine作為接口，趁這個機會，來試試UniTask可以怎麼讓程式撰寫變得有所不同。\n\nSync vs Async印象好像從大一的計概？還是後來的組合語言或計組之類的課程，都常常提到同步和非同步的差別。不太確定課本精準的定義，不過Synchronize(sync, 同步)大致上是指在程式執行過程中，必須等前一個訊號執行完成，才繼續進行下一個指令，而Asynchronize(async, 非同步)則是反過來，這個訊號並不一定要等到執行到了盡頭，才開始下一個指令的運行。\n在一般寫程式的時候，大部分的程式碼都是逐行、同步進行的(雖然流水線、指令級同步等東西存在，但邏輯上還是逐行在跑)，然而，可想而知，有許多的指令會造成執行上的瓶頸，例如：IO, 網路相關的動作，相對於程式碼都是緩慢的，以同步方式執行，就必須要在這裡等到天荒地老，CPU直接等到睡著，可想而知這不是個好點子。\nCallback此時，就需要用到callback function這種做法。傳進一個delegate (或是function pointer，如果你熱愛C語言的話)，等到事件結束後，再繼續執行這個完成後的function，當然可以將IO得到的資訊作為參數之類的。\n許多library都是類似底下這種形式呼叫：\nvoid DoSomethingCool()\n&#123;\n    DoSomethingNeedToWait(ioStuff =&gt; \n    &#123;\n        DoSomethingAfterHugeIO(ioStuff);\n    &#125;);\n&#125;\n\nvoid DoSomethingNeedToWait(System.Action&lt;IOStuff&gt; callback)\n&#123;\n    var IOStuff = SomethingHugeIO();\n    callback(IOStuff);\n&#125;\n\nvoid DoSomethingNeedToWait(System.Action callback)\n&#123;\n    SomethingHugeIO();\n    callback();\n&#125;\n\n扣掉這樣IO其實還是同步的吐槽，這樣的作法已經非常酷，但想像到底下的狀況當IO結束之後，必須送到某個伺服器等待回應，程式碼就會開始出現怪味：\nvoid DoSomethingCool()\n&#123;\n    DoSomethingNeedToWait(ioStuff =&gt; \n    &#123;\n        DoSomethingNeedACoolServer(ioStuff, res =&gt;\n        &#123;\n            DoTheRealCoolThings(res);\n        &#125;);\n    &#125;);\n&#125;\n\nvoid DoSomethingNeedToWait(System.Action&lt;IOStuff&gt; callback)\n&#123;\n    var IOStuff = SomethingHugeIO();\n    callback(IOStuff);\n&#125;\n\nvoid DoSomethingNeedACoolServer(IOStuff coolData, System.Action&lt;Response&gt; onResponsed)\n&#123;\n    var response = SomethingWaitServer();\n    onResponsed(response);\n&#125;\n\n當然，扣掉request好像完全不需要handle error的吐槽，我們可以看到DoSomethingCool的主函式，已經開始出現波動拳的力量。\n這對於一個加班N小時候看到這段程式碼的工程師來說，很有可能就是壓垮他的最後一片稻草了。\n想想一般的工程師，回到家之後沒有女僕龍可以陪伴，我們真的不需要互相傷害，製造出這種callback hell，幸好，Unity裡面早有一個常見方式可以克服這件事，那就是Coroutine。\nCoroutineCoroutine使用C#的迭代器模式，利用一個返回迭代器的Function來進行序列執行，並且在每一次Update後，做一次tick觸發。\n原本的程式碼，可以改寫成這種形式：\nIOStuff _ioStuff;\nResponse _response;\n\nvoid Start()\n&#123;\n    StartCoroutine(DoSomethingCool());\n&#125;\n\nIEnumerator DoSomethingCool()\n&#123;\n    yield return DoSomethingNeedToWait();\n    yield return DoSomethingNeedACoolServer(_ioStuff);\n    DoTheRealCoolThings(_response);\n&#125;\n\nIEnumerator DoSomethingNeedToWait()\n&#123;\n    yield return SomethingHugeIO(out _ioStuff);\n&#125;\n\nIEnumerator DoSomethingNeedACoolServer(IOStuff coolData)\n&#123;\n    yield return SomethingWaitServer(out _response);\n&#125;\n\n顯然可以感覺到，比波動拳安全許多，yield return後的事情，只會在一個frame進行一次，如果還沒完成，會等到下一次tick時再次檢查，這樣可以迴避掉波動拳，並且讓半夜看到這段程式碼的工程師感到舒暢許多，明顯可以一眼看出在等什麼以及資料流的走向。\n然而，Coroutine必須綁定monobehaviour進行，以及每一次Update時unity都需要費心來關切他，而且try-catch區段在yield語法下不可用，或許我們不需要那麼多心思在製作這樣的串列上，而是有其他替代方法。\nUniTaskUniTask是利用C#的async/await語言機制整合進unity元件的一個解決方法，可以用雷同C# Task的方式來進行unity元件的操作，獲得一個更優雅的call chain，並且不需要擔心allocation問題(至少readme上是寫no allocation)。(async在語言層面上應該是類似C++的std::this_thread::yield，將這個thread的優先權交出，但C#的async會不會真的交出優先權我不曉得)\n我想這邊開始就不用上面提到的那些假舉例，而是用我最近實際遇到的使用情境來說明。\n前些日子在特價的時候，我買了MoreMountain的Feel這個插件，他可以使用預先做好的元件，做出許多很酷的效果，包含Cinemachine的一些元件互動，或是Post Effect的動態等。\n可以做出像這樣的打擊效果：\n順帶一提，再加入效果前的樣子是這樣的：\n\n可以說是相當方便的插件，端詳他的程式碼後，發現他實作一連串演出的呼叫MMFeedbacks是使用coroutine呼叫的，倘若我們想要在這一連串演出結束過後，再銜接什麼演出，就必須遇到前面提到的Coroutine問題。\nMMFeedback的呼叫介面如下：\npublic virtual void PlayFeedbacks()\n&#123;\n    StartCoroutine(PlayFeedbacksInternal(this.transform.position, FeedbacksIntensity));\n&#125;\n\n其實他有提供幾個Event可以直接對接，但如果我們想和其他coroutine，或是tweening演出一起寫成一個function，使用event的撰寫就會變得冗長且難以維護。\n用Event的方式來註冊的話，可以寫成如下：\nprivate void HitSomething(Collider[] hits)\n&#123;\n    m_HitPos = GetRecent(3);\n    OnHit?.Invoke();\n    FeedbackHandler.Events.OnComplete.AddListener(() =&gt;\n    &#123;\n        TriggerAfterFeedback(hits);\n    &#125;);\n    FeedbackHandler.PlayFeedbacks();\n&#125;\n\n這段程式碼有幾個問題，第一個是Event裡面的匿名function，執行時間其實在PlayFeedbacks底下，這導致了程式碼的順序與執行順序的不同，降低了一部分的可讀性。\n再者，這段程式碼其實沒有寫到RemoveListener的部分，如果每次呼叫都AddListener一次，會造成顯著的memory leak，當然我們也可以將event的註冊拉到物件初始化的時候，但這樣會將邏輯更進一步的分離，可讀性再次下降。\n最後，就是許多演出的串列如果在同一個function實作，最終會變成上面所說的波動拳問題，要將這個做法寫得漂亮，需要耗費許多苦心。\n還好，這個插件還提供第二個方案，也就是前面提到Unity對於callback hell的一個解法，也就是Coroutine。\nMMFeedback對於Coroutine的接口如下：\npublic virtual IEnumerator PlayFeedbacksCoroutine(Vector3 position3,...)\n&#123;\n    return PlayFeedbacksInternal(position, feedbacksIntensity, forceRevert);\n&#125;\n\n可以看到，這個接口直接回傳了一個迭代器，我們可以簡單的利用這個IEnumrator改寫成如下：\nprivate void HitSomething(Collider[] hits)\n&#123;\n    StartCoroutine(DoHitSomething(hits));\n&#125;\n\nprivate IEnumerator DoHitSomething(Collider[] hits)\n&#123;\n    m_HitPos = GetRecent(3);\n    OnHit?.Invoke();\n    yield return FeedbackHandler.PlayFeedbacksCoroutine(this.transform.position);\n    TriggerAfterFeedback(hits);\n&#125;\n\n這樣就可以用Coroutine的方式，解決掉event可能產生的一些問題，但這樣就會產生一些coroutine的對應消耗，以及handle coroutine結束與否的問題，而前面提到的UniTask，可以用更優雅的方式做到。\n我們可以先為MMFeedbacks添加一個接口function如下：\npublic virtual async UniTask PlayFeedbacksAsync()\n&#123;\n    await PlayFeedbacksInternal(this.transform.position, FeedbacksIntensity);\n&#125;\n\nUniTask會時做一個awaiter，將coroutine的執行完成與否這件事封裝到UniTask自己的internal enumerator之中，這樣我們呼叫時，就可以簡單地寫成這樣：\nprivate async UniTask OnHitSomething(Collider[] hits)\n&#123;\n    m_HitPos = GetRecent(3);\n    OnHit?.Invoke();\n    await FeedbackHandler.PlayFeedbacksAsync();\n    TriggerAfterFeedback(hits);\n&#125;\n\n這樣整個演出就可以簡單的寫成一個async function，其中的calling chain也會變得優雅許多，甚至如果有多個演出同時進行的時候，可以寫成下面的形式：\nprivate async void DoTonsOfScreenPlay()\n&#123;\n    List&lt;UniTask&gt; screenPlays = new List&lt;UniTask&gt;();\n    screenPlays.Add(OnHitSomething()); \n    screenPlays.Add(OnHitSomethingCool()); \n    screenPlays.Add(OnHitSomethingCute()); \n    screenPlays.Add(OnHitSomethingAhoy());\n    screenPlays.Add(LoadNextPartyAddressables());\n    await UniTask.WhenAll(screenPlays);\n\n    // After all screenplay end\n    await SceneManager.LoadSceneAsync(&quot;Next Party&quot;);\n&#125;\n\n這樣我們可以在播出許多演出的同時，偷偷地在背後讀取Assets，直到一切都準備就緒了，馬上開始進行下一個場景的切換，達成一些無縫切換的效果。順帶一提，轉場的概念可以去看我最敬愛的blog writer，羽毛的熱門文章：重新載入&amp;場景轉換，肯定會獲益良多。\nConclusionUniTask是個非常酷的插件，可以將許多演出與callback的可怕義大利麵程式碼，轉換成一眼就能看出結果的程式碼，同個作者的UniRx也是非常酷的插件，有興趣的可以去看看這個作者的repo們。\n延伸閱讀UniTask Repo\nUniTask v2 — Zero Allocation async/await for Unity, with Asynchronous LINQ\n【Unite 2017 Tokyo】「黒騎士と白の魔王」にみるC#で統一したサーバー/クライアント開発と現実的なUniRx使いこなし術\nUniRx Repo\nUniRx DoTween Integration\n","categories":["Unity"],"tags":["Basic","Unity","Programming Tips"]}]